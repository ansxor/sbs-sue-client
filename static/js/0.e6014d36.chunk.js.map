{"version":3,"sources":["parse.js"],"names":["Parse","lang","create","x","document","createElement","createText","createTextNode","creator","tag","node","newEvent","name","event","createEvent","initEvent","defaultProtocol","window","location","protocol","getPath","decodeURIComponent","hash","substr","split","options","append","parent","child","branch","nodes","forEach","appendChild","text","lineBreak","line","invalid","reason","className","title","textContent","code","args","contents","language","setAttribute","block","icode","audio","video","url","youtube","preview","match","getYoutubeID","link","div","href","style","backgroundImage","time","end","loop","id","callback","XMLHttpRequest","open","onload","status","JSON","parse","responseText","items","e","send","getYoutube","data","snippet","channelTitle","ifc","onclick","preventDefault","dispatchEvent","iframe","src","stop","innerHTML","bg","opt","color","root","createDocumentFragment","bold","italic","underline","strikethrough","heading","level","quote","cite","list","undefined","listStyleType","item","index","test","toLowerCase","urlProtocol","removeAttribute","hash1","hash2","n","getElementsByName","scrollIntoView","table","opts","container","row","cell","h","rs","rowSpan","cs","colSpan","c","backgroundColor","a","textAlign","image","error","stack","err","pre","align","arg","superscript","subscript","anchor","spoiler","button","this","getAttribute","box","i","skipNextLineBreak","textBuffer","curr","output","startOfLine","leadingSpaces","blocks","cache","editorCache","scan","init","scanFunc","myBlocks","type","used","top","length","restore","pos","eatChar","chr","matchNext","str","readUrl","allow","start","isUrlChar","substring","stackContains","top_is","endBlock","flushText","pop","addBlock","addLineBreak","addText","endAll","startBlock","tryGetCached","push","isUrlStart","make","findUnusedCached","codeInput","lineStart","charAt","tags","sub","sup","endLine","readEnv","closeAll","doMarkup","headingLevel","addMulti","char_in","trim","count","inBrackets","big","eaten","columns","cells","rowspans","map","span","filter","header","startCell","replace","indexOf","codeText","readLink","readTagName","props","readProps","func","Object","assign","end2","propst","pair","string","sep","split1","embed","part2","urlType","readBracketedLink","after","readPlainLink","force","indent","symbol","canStartMarkup","canEndMarkup","bbcode","codeArg","noNesting","b","u","s","h1","h2","h3","tr","td","th","img","specialBlock","inline","point","cancel","readArgList","endTag","isTagChar","key","fallback","result","linkRegex","last","exec","parseLang","alert"],"mappings":"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","file":"static/js/0.e6014d36.chunk.js","sourcesContent":["/* eslint-disable no-cond-assign */\n/* eslint-disable no-mixed-operators */\n/* eslint-disable no-redeclare */\n/* eslint-disable no-loop-func */\n/* eslint-disable no-func-assign */\n/* eslint-disable no-unused-vars */\n/* eslint-disable no-useless-concat */\n/* eslint-disable no-useless-escape */\n/* eslint-disable eqeqeq */\n/* eslint-disable new-parens */\n/* eslint-disable no-undef */\n/* eslint-disable no-restricted-globals */\n// TODO:\n// the system for handling resizes (for autoscroll) is a big mess\n// maybe try creating a custom event that gets triggered whenever\n// an element's height will be changed (when clicking an image, activating a youtube player, etc.)\n// and listen for it on the root element externally\n// see: document.createEvent\n\nvar Parse = {\n\tlang:{}\n}\n\n// parser options\n// this can be easily changed\n// to control the output\n\n// most functions should return an object containing:\n//   .node or .nodes - the node(s) to insert\n//   .branch - (optional if .node was specified) which node to insert children into\n//   .block - `true` if the element is display: block or similar.\n\n// most functions take input in the form of either\n// (args) (or (args, contents) for things where the contents are plain text)\n// (code blocks, [img], etc.)\n// the unnamed argument uses a key of \"\"\n// args without a value are set to true\n// for example, `[tag=test key=value option]` would pass\n// {\"\":\"test\", key:\"value\", option:true}\n;(function() {\n\tfunction create(x) {\n\t\treturn document.createElement(x)\n\t}\n\tfunction createText(x) {\n\t\treturn document.createTextNode(x)\n\t}\n\tfunction creator(tag) {\n\t\treturn function() {\n\t\t\treturn {node:create(tag)}\n\t\t}\n\t}\n\tfunction newEvent(name) {\n\t\tvar event = document.createEvent(\"Event\");\n\t\tevent.initEvent(name, true, true);\n\t\treturn event;\n\t}\n\tfunction getYoutube(id, callback) {\n\t\tvar x = new XMLHttpRequest\n\t\tx.open(\"GET\", \"https://www.googleapis.com/youtube/v3/videos?part=snippet&id=\"+id+\"&key=AIzaSyBKka_xlF5pV4SMKLtQGIhOgyQsjF7UI-U\");\n\t\tx.onload = function() {\n\t\t\tif (x.status != 200)\n\t\t\t\treturn\n\t\t\ttry {\n\t\t\t\tvar json = JSON.parse(x.responseText)\n\t\t\t\tvar video = json.items[0]\n\t\t\t\tcallback(video);\n\t\t\t} catch(e){}\n\t\t}\n\t\tx.send();\n\t}\n\tfunction defaultProtocol() {\n\t\tif (window.location.protocol == 'http:')\n\t\t\treturn 'http:'\n\t\telse\n\t\t\treturn 'https:'\n\t}\n\tfunction getYoutubeID(url) {\n\t\tvar match = url.match(/(?:https?:\\/\\/)?(?:www\\.)?youtu\\.?be(?:\\.com)?\\/?.*(?:watch|embed)?(?:.*v=|v\\/|\\/)([\\w\\-_]+)\\&?/)\n\t\tif (match)\n\t\t\treturn match[1]\n\t\treturn null\n\t}\n\t// returns [protocol, rest of url] or [null, url]\n\tfunction urlProtocol(url) {\n\t\tvar match = url.match(/^([-\\w]+:)([^]*)$/)\n\t\tif (match)\n\t\t\treturn [match[1].toLowerCase(), match[2]]\n\t\treturn [null, url]\n\t}\n\n\t// so normally our path structure will look like\n\t// url#path?query#fragment\n\t// with #s in the path and query escaped with %\n\t// however, some browsers escape duplicate #s automatically, so this has to be dealt with somehow\n\t// I'm not sure of a good way which still allows # to be used in the path+query, though\n\t// may need to use a different character...\n\tfunction getPath() {\n\t\tvar hash = decodeURIComponent(location.hash.substr(1))\n\t\treturn hash.split(\"#\")\n\t}\n\t\n\tParse.options = {\n\t\tappend: function (parent, child) {\n\t\t\tparent = parent.branch || parent.node\n\n\t\t\tif (child.nodes)\n\t\t\t\tchild.nodes.forEach(function(x){\n\t\t\t\t\tparent.appendChild(x)\n\t\t\t\t})\n\t\t\telse\n\t\t\t\tparent.appendChild(child.node)\n\t\t},\n\t\t\n\t\t//========================\n\t\t// nodes without children:\n\t\ttext: function(text) {\n\t\t\treturn {node: createText(text)}\n\t\t},\n\t\tlineBreak: creator('br'),\n\t\tline: creator('hr'),\n\t\t// used for displaying invalid markup\n\t\t// reason is currently unused\n\t\tinvalid: function(text, reason) {\n\t\t\tvar node = create('span')\n\t\t\tnode.className = 'invalid'\n\t\t\tnode.title = reason\n\t\t\tnode.textContent = text\n\t\t\treturn {node:node}\n\t\t},\n\t\t// code block\n\t\tcode: function(args, contents) {\n\t\t\tvar language = args[\"\"]\n\t\t\tvar node = create('pre')\n\t\t\tnode.setAttribute('data-lang', language)\n\t\t\t// node.innerHTML = highlightSB(contents, language)\n\t\t\treturn {block:true, node:node}\n\t\t},\n\t\t// inline code\n\t\ticode: function(args, contents) {\n\t\t\tvar node = create('code')\n\t\t\tnode.textContent = contents\n\t\t\treturn {node:node, block:false}\n\t\t},\n\t\taudio: function(args) {\n\t\t\tvar node = create('audio')\n\t\t\tnode.setAttribute('controls', \"\")\n\t\t\tnode.setAttribute('src', args[\"\"])\n\t\t\treturn {block:true, node:node}\n\t\t},\n\t\tvideo: function(args) {\n\t\t\tvar url = args[\"\"]\n\t\t\tvar node = create('video')\n\t\t\tnode.setAttribute('controls', \"\")\n\t\t\tnode.setAttribute('src', url)\n\t\t\treturn {block:true, node:node}\n\t\t},\n\t\tyoutube: function(args, preview) {\n\t\t\tvar url = args[\"\"]\n\t\t\tvar protocol = defaultProtocol()\n\t\t\tvar match = getYoutubeID(url)\n\t\t\tvar link = create('a')\n\t\t\tvar div = create('div')\n\t\t\tdiv.className = \"youtube\"\n\t\t\tdiv.appendChild(link)\n\t\t\tlink.href = url\n\t\t\t\n\t\t\tif (match) {\n\t\t\t\tlink.style.backgroundImage = 'url(\"'+protocol+\"//i.ytimg.com/vi/\"+match+\"/mqdefault.jpg\"+'\")'\n\t\t\t\tvar time = url.match(/[&?](?:t|start)=(\\w+)/);\n\t\t\t\tvar end = url.match(/[&?](?:end)=(\\w+)/);\n\t\t\t\tvar loop = url.match(/[&?]loop(=|&|$)/);\n\t\t\t\tif (!preview)\n\t\t\t\t\tgetYoutube(match, function(data) {\n\t\t\t\t\t\tvar title = create('div')\n\t\t\t\t\t\ttitle.className = 'pre videoTitle'\n\t\t\t\t\t\ttitle.textContent = data.snippet.title\n\t\t\t\t\t\tlink.appendChild(title)\n\t\t\t\t\t\tlink.appendChild(create('br'));\n\t\t\t\t\t\ttitle = create('div')\n\t\t\t\t\t\ttitle.className = 'pre videoAuthor'\n\t\t\t\t\t\ttitle.textContent = data.snippet.channelTitle\n\t\t\t\t\t\tlink.appendChild(title)\n\t\t\t\t\t})\n\t\t\t\tvar ifc = create('span')\n\t\t\t\tlink.appendChild(ifc)\n\t\t\t\tlink.onclick = function(e) {\n\t\t\t\t\te.preventDefault()\n\t\t\t\t\tdiv.dispatchEvent(newEvent(\"beforeSizeChange\"));\n\t\t\t\t\tvar iframe = create('iframe')\n\t\t\t\t\tvar src = \"https://www.youtube-nocookie.com/embed/\"+match+\"?autoplay=1\";\n\t\t\t\t\tif (time)\n\t\t\t\t\t\tsrc += \"&start=\"+time[1];\n\t\t\t\t\tif (end)\n\t\t\t\t\t\tsrc += \"&end=\"+end[1];\n\t\t\t\t\tif (loop)\n\t\t\t\t\t\tsrc += \"&loop=1&playlist=\"+match;\n\t\t\t\t\tiframe.src = src;\n\t\t\t\t\tifc.appendChild(iframe)\n\t\t\t\t\tdiv.className = \"youtube playingYoutube\"\n\t\t\t\t\tdiv.dispatchEvent(newEvent(\"afterSizeChange\"));\n\t\t\t\t}\n\t\t\t\tvar stop = create('button')\n\t\t\t\tstop.textContent = \"x\"\n\t\t\t\tstop.onclick = function(e) {\n\t\t\t\t\te.preventDefault()\n\t\t\t\t\tdiv.dispatchEvent(newEvent(\"beforeSizeChange\"));\n\t\t\t\t\tifc.innerHTML = \"\"\n\t\t\t\t\tdiv.className = \"youtube\"\n\t\t\t\t\tdiv.dispatchEvent(newEvent(\"afterSizeChange\"));\n\t\t\t\t}\n\t\t\t\tdiv.appendChild(stop)\n\t\t\t}\n\t\t\treturn {block:true, node:div}\n\t\t},\n\t\tbg: function(opt) {\n\t\t\tvar node=document.createElement(\"span\")\n\t\t\tvar color = opt[\"\"]\n\t\t\tif (color) {\n\t\t\t\tnode.setAttribute(\"data-bgcolor\", color)\n\t\t\t}\n\t\t\treturn {node:node}\n\t\t},\n\t\t\n\t\t//=====================\n\t\t// nodes with children\n\t\troot: function() {\n\t\t\tvar node = document.createDocumentFragment()\n\t\t\treturn {block:true, node:node}\n\t\t},\n\t\tbold: creator('b'),\n\t\titalic: creator('i'),\n\t\tunderline: creator('u'),\n\t\tstrikethrough: creator('s'),\n\t\theading: function(level) { // input: 1, 2, or 3\n\t\t\t// output: h2-h4\n\t\t\treturn {block:true, node:create('h'+(level+1))}\n\t\t},\n\t\t\n\t\tquote: function(args) {\n\t\t\t// <blockquote><cite> arg </cite><br> ... </blockquote>\n\t\t\tvar name = args[\"\"]\n\t\t\tvar node = create('blockquote')\n\t\t\tif (name) {\n\t\t\t\tvar cite = create('cite')\n\t\t\t\tcite.textContent = name\n\t\t\t\tnode.appendChild(cite)\n\t\t\t\tnode.appendChild(create('br'))\n\t\t\t}\n\t\t\treturn {block:true, node:node}\n\t\t},\n\t\tlist: function(args) {\n\t\t\t// <ul> ... </ul>\n\t\t\tif (args[\"\"]!=undefined) {\n\t\t\t\tvar list = create('ol')\n\t\t\t\tlist.style.listStyleType = args[\"\"]\n\t\t\t} else\n\t\t\t\tlist = create('ul')\n\t\t\treturn {block:true, node:list}\n\t\t},\n\t\titem: function(index) {\n\t\t\treturn {block:true, node:create('li')}\n\t\t},\n\t\t//creator('li'), // (list item)\n\t\t\n\t\tlink: function(args) {\n\t\t\t// <a href= url> ... </a>\n\t\t\tvar url = args[\"\"]\n\t\t\t// important, do not remove, prevents script injection\n\t\t\tif (/^ *javascript:/i.test(url))\n\t\t\t\turl = \"\"\n\t\t\t\n\t\t\tvar node = create('a')\n\t\t\t\n\t\t\tvar protocol = urlProtocol(url)\n\t\t\tnode.setAttribute('target', \"_blank\")\n\t\t\tif (protocol[0] == \"sbs:\") {\n\t\t\t\t// put your custom local url handling code here\n\t\t\t\turl = \"#\"+protocol[1]\n\t\t\t\tnode.removeAttribute('target')\n\t\t\t} else if (!protocol[0]) {\n\t\t\t\tif (url[0] == \"#\") {\n\t\t\t\t\t// put your fragment link handling code here\n\t\t\t\t\tvar hash1 = getPath()\n\t\t\t\t\tvar name = url.substr(1)\n\t\t\t\t\tlet hash = \"#\"+hash1[0]+\"#\"+name\n\t\t\t\t\turl = hash\n\t\t\t\t\tnode.onclick = function(e) {\n\t\t\t\t\t\tvar hash2 = getPath()\n\t\t\t\t\t\tif (hash1[0]==hash2[0] && hash2[1]==name) {\n\t\t\t\t\t\t\tvar n = document.getElementsByName(\"_anchor_\"+name)\n\t\t\t\t\t\t\tif (n[0])\n\t\t\t\t\t\t\t\tn[0].scrollIntoView()\n\t\t\t\t\t\t\te.preventDefault()\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\twindow.location.hash = hash\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\t// urls without protocol get https:// or http:// added\n\t\t\t\t\turl = defaultProtocol()+\"//\"+url\n\t\t\t\t}\n\t\t\t\t\n\t\t\t}\n\t\t\tnode.setAttribute('href', url)\n\t\t\treturn {node:node}\n\t\t},\n\t\t\n\t\ttable: function(opts) {\n\t\t\t// <div class=\"tableContainer\"><table> ... </table></div>\n\t\t\tvar container = create('div')\n\t\t\tcontainer.className = \"tableContainer\"\n\t\t\tvar node = create('table')\n\t\t\tcontainer.appendChild(node)\n\t\t\treturn {\n\t\t\t\tblock: true,\n\t\t\t\tnode: container,\n\t\t\t\tbranch: node\n\t\t\t}\n\t\t},\n\t\t\n\t\trow: creator('tr'),\n\t\t\n\t\tcell: function (opt) {\n\t\t\t// <td> ... </td> etc.\n\t\t\tvar node = opt.h ?\n\t\t\t\t create('th') :\n\t\t\t\t create('td')\n\t\t\tif (opt.rs)\n\t\t\t\tnode.rowSpan = opt.rs\n\t\t\tif (opt.cs)\n\t\t\t\tnode.colSpan = opt.cs\n\t\t\tif (opt.c) {\n\t\t\t\tif (opt.c[0] == \"#\")\n\t\t\t\t\tnode.style.backgroundColor = opt.c\n\t\t\t\tnode.setAttribute(\"data-bgcolor\", opt.c)\n\t\t\t}\n\t\t\tif (opt.a) {\n\t\t\t\tnode.style.textAlign = opt.a\n\t\t\t}\n\t\t\tnode.className = \"cell\"\n\t\t\treturn {node:node}\n\t\t},\n\t\t\n\t\timage: function(args) {\n\t\t\t// <img src= arg tabindex=\"-1\">\n\t\t\tvar url = args[\"\"]\n\t\t\tvar node = create('img')\n\t\t\tnode.setAttribute('src', url)\n\t\t\tnode.setAttribute('tabindex', \"-1\")\n\t\t\t/*node.onload = function() {\n\t\t\t  if (window.scrollToAuto)\n\t\t\t  scrollToAuto()\n\t\t\t  }*/\n\t\t\treturn {node:node, block:true}\n\t\t},\n\t\t\n\t\t// parser error message\n\t\terror: function(e, stack) {\n\t\t\t// <div class=\"error\">Error while parsing:<pre> stack trace </pre>Please report this</div>\n\t\t\tvar node = create('div')\n\t\t\tnode.className = \"error\"\n\t\t\tnode.appendChild(createText(\"Markup parsing error: \"))\n\t\t\tvar err = create('code')\n\t\t\terr.textContent = e\n\t\t\tnode.appendChild(err)\n\t\t\tnode.appendChild(createText(\"\\nPlease report this!\"))\n\t\t\tif (stack) {\n\t\t\t\tvar pre = create('pre')\n\t\t\t\tpre.textContent = stack\n\t\t\t\tnode.appendChild(pre)\n\t\t\t}\n\t\t\treturn {node:node, block:true}\n\t\t},\n\t\t\n\t\talign: function(args) {\n\t\t\tvar node = create('div')\n\t\t\tvar arg = args[\"\"]\n\t\t\tif (arg == 'left' || arg == 'right' || arg == 'center')\n\t\t\t\tnode.style.textAlign = arg\n\t\t\treturn {node:node, block:true}\n\t\t},\n\t\tsuperscript: creator('sup'),\n\t\tsubscript: creator('sub'),\n\t\tanchor: function(args) {\n\t\t\tvar name = args[\"\"]\n\t\t\tvar node = create('a')\n\t\t\t// put your anchor name handler here\n\t\t\t// I prefix the names to avoid collision with node ids\n\t\t\t// which use the same namespace as name\n\t\t\tnode.name = \"_anchor_\"+name\n\t\t\treturn {node:node, block:true}\n\t\t},\n\t\tspoiler: function(args) {\n\t\t\t// <button> arg </button><div class=\"spoiler\"> ... </div>\n\t\t\t// I'd use <summary>/<details> but it's not widely supported\n\t\t\t// and impossible to style with css\n\t\t\t// this probably needs some aria attribute or whatever\n\t\t\tvar button = create('button')\n\t\t\tbutton.onclick = function() {\n\t\t\t\tif (this.getAttribute('data-show') == null)\n\t\t\t\t\tthis.setAttribute('data-show',\"\")\n\t\t\t\telse\n\t\t\t\t\tthis.removeAttribute('data-show')\n\t\t\t}\n\t\t\tbutton.className = 'spoilerButton'\n\t\t\tvar name = args[\"\"]\n\t\t\tif (name == true)\n\t\t\t\tname = \"spoiler\"\n\t\t\tbutton.textContent = name\n\t\t\t\n\t\t\tvar box = create('div')\n\t\t\tbox.className = \"spoiler\"\n\t\t\t\n\t\t\treturn {\n\t\t\t\tblock: true,\n\t\t\t\tnodes: [button, box],\n\t\t\t\tbranch: box\n\t\t\t}\n\t\t}\n\t}\n})()\n\n;(function(){\n\t/***********\n\t ** STATE **\n    ***********/\n\tvar c,i,cache = null,code\n\tvar editorCache = {video:{},audio:{},youtube:{}}\n\tvar skipNextLineBreak\n\tvar textBuffer\n\tvar curr, output\n\tvar stack\n\tvar startOfLine\n\tvar leadingSpaces\n\tvar blocks\n\tfunction scan(){}\n\n\tfunction errorHandle(func) {\n\t\ttry {\n\t\t\tfunc()\n\t\t} catch (e) {\n\t\t\t// todo: close all blocks and add error message\n\t\t}\n\t}\n\t\n\tfunction init(scanFunc, myBlocks, text) {\n\t\tscan = scanFunc\n\t\tcode = text\n\t\tif (cache)\n\t\t\tfor (type in cache)\n\t\t\t\tfor (arg in cache[type])\n\t\t\t\t\tcache[type][arg].forEach(function(x){\n\t\t\t\t\t\tx.used = false\n\t\t\t\t\t})\n\t\tblocks = myBlocks\n\t\tleadingSpaces = 0\n\t\tstartOfLine = true\n\t\tskipNextLineBreak = false\n\t\ttextBuffer = \"\"\n\t\toutput = curr = options.root()\n\t\tstack = [{node:curr, type:'root'}]\n\t\tstack.top = function() {\n\t\t\treturn stack[stack.length-1]\n\t\t}\n\t\trestore(0)\n\t}\n\t// move to pos\n\tfunction restore(pos) {\n\t\ti = pos-1\n\t\tscan()\n\t}\n\n\t//try to read a char\n\tfunction eatChar(chr) {\n\t\tif (c == chr) {\n\t\t\tscan()\n\t\t\treturn true\n\t\t}\n\t}\n\n\tfunction matchNext(str) {\n\t\treturn code.substr(i, str.length) == str\n\t}\n\t\n\t// read a url\n\t// if `allow` is true, url is only ended by end of file or ]] or ][ (TODO)\n\tfunction readUrl(allow) {\n\t\tvar start = i\n\t\tif (allow)\n\t\t\twhile (c && c!=\"]\" && c!=\"[\")\n\t\t\t\tscan()\n\t\telse\n\t\t\twhile (isUrlChar(c))\n\t\t\t\tscan()\n\t\treturn code.substring(start, i)\n\t}\n\n\t\n\t// ew regex\n\tfunction isUrlChar(c) {\n\t\t// removed ) because interferes with stuff too much\n\t\t// other problems common are\n\t\t// - period, comma, etc. after url\n\t\treturn c && (/[-\\w\\$\\.+!*'(,;/\\?:@=&#%]/).test(c)\n\t}\n\t/***********\n    ** stack **\n    ***********/\n\tfunction stackContains(type) {\n\t\tfor (var i=0; i<stack.length; i++) {\n\t\t\tif (stack[i].type == type) {\n\t\t\t\treturn true\n\t\t\t}\n\t\t}\n\t\treturn false\n\t}\n\tfunction top_is(type) {\n\t\tvar top = stack.top()\n\t\treturn top && top.type == type\n\t}\n\t\n\t/****************\n    ** outputting **\n    ****************/\n\tfunction endBlock() {\n\t\tflushText()\n\t\tvar item = stack.pop()\n\t\tif (item.node && item.node.block)\n\t\t\tskipNextLineBreak = true\n\n\t\tif (stack.length) {\n\t\t\tvar i=stack.length-1\n\t\t\t// this skips {} fake nodes\n\t\t\t// it will always find at least the root <div> element I hope\n\t\t\twhile (!stack[i].node){\n\t\t\t\ti--\n\t\t\t}\n\t\t\tcurr = stack[i].node\n\t\t} else {\n\t\t\tcurr = null\n\t\t}\n\t}\n\t\n\t// add simple block with no children\n\tfunction addBlock(node) {\n\t\tflushText()\n\t\toptions.append(curr, node)\n\t}\n\n\t// output contents of text buffer\n\tfunction flushText() {\n\t\tif (textBuffer) {\n\t\t\toptions.append(curr, options.text(textBuffer))\n\t\t\ttextBuffer = \"\"\n\t\t}\n\t}\n\n\t// add linebreak to output\n\t// todo: skipping linebreaks should skip / *\\n? */ (spaces before/after!)\n\t// so like [h1]test[/h1] [h2]test[/h2]\n\t// no extra linebreak there\n\tfunction addLineBreak() {\n\t\tif (skipNextLineBreak) {\n\t\t\tskipNextLineBreak = false\n\t\t} else {\n\t\t\tflushText()\n\t\t\taddBlock(options.lineBreak())\n\t\t}\n\t}\n\n\t// add text to output (buffered)\n\tfunction addText(text) {\n\t\tif (text) {\n\t\t\ttextBuffer += text\n\t\t\tskipNextLineBreak = false\n\t\t}\n\t}\n\t\n\t// call at end of parsing to flush output\n\tfunction endAll() {\n\t\tflushText()\n\t\twhile (stack.length)\n\t\t\tendBlock()\n\t}\n\t\n\t/*****************\n    ** cache stuff **\n    *****************/\n\tfunction findUnusedCached(cache, type, arg) {\n\t\tvar list = cache[type][arg]\n\t\tif (!list)\n\t\t\treturn null\n\t\tfor (var i=0;i<list.length;i++) {\n\t\t\tif (!list[i].used)\n\t\t\t\treturn list[i]\n\t\t}\n\t\treturn null\n\t}\n\n\tfunction startBlock(type, data, arg) {\n\t\tdata.type = type\n\t\tif (type) {\n\t\t\t\n\t\t\tvar node = tryGetCached(cache, type, arg && arg[\"\"], function() {\n\t\t\t\treturn blocks[type](arg)\n\t\t\t})\n\t\t\tdata.node = node\n\t\t\tif (node.block)\n\t\t\t\tskipNextLineBreak = true\n\t\t\t\n\t\t\tflushText()\n\t\t\toptions.append(curr, node)\n\t\t\tcurr = node\n\t\t}\n\t\tstack.push(data)\n\t\treturn data\n\t}\n\t// check for /\\b(http://|https://|sbs:)/ basically\n\tfunction isUrlStart() {\n\t\tif (code[i-1] && /\\w/.test(code[i-1]))\n\t\t\treturn false\n\t\treturn matchNext(\"http://\") || matchNext(\"https://\") || matchNext(\"sbs:\")\n\t}\n\t\n\t// try to get a node from cache.\n\t// will get nodes where `type` and `arg` matches\n\t// if not found, returns make(), and adds to cache\n\tfunction tryGetCached(cache, type, arg, make) {\n\t\tvar node\n\t\tif (cache && type && cache[type]) {\n\t\t\tvar item = findUnusedCached(cache, type, arg)\n\t\t\tif (item) {\n\t\t\t\titem.used = true\n\t\t\t\tnode = item.node\n\t\t\t}\n\t\t}\n\t\tif (!node && type) {\n\t\t\tnode = make()\n\t\t\tif (cache && cache[type]) {\n\t\t\t\tif (!cache[type][arg])\n\t\t\t\t\tcache[type][arg] = []\n\t\t\t\tcache[type][arg].push({node:node, used:true})\n\t\t\t}\n\t\t}\n\t\treturn node\n\t}\n\n\tvar options = Parse.options\n\t\n\tParse.lang['12y'] = function(codeInput, preview) {\n\t\t// so what happens here is\n\t\t// when a video needs to be generated\n\t\t// first, check the cache. if it exists there, insert it\n\t\t// (remember that a node can only exist in one place in the DOM though)\n\t\t// now, if the video needs to be created, and preview mode is enabled,\n\t\t// a place holder is generated (and not stored in the cache)\n\t\t// if preview is disabled (and cache is passed), the video is generated\n\t\t// and stored in the cache, to be reused later\n\t\t\n\t\t// in the editor, this should be called normally with preview mode enabled\n\t\t// then maybe after a delay of no typing, call it with preview off,\n\t\t// to generate any new videos\n\t\t// or don't use preview at all! maybe it's fine!\n\n\t\tinit(function() {\n\t\t\tif (c == \"\\n\" || !c)\n\t\t\t\tlineStart()\n\t\t\telse if (c != \" \")\n\t\t\t\tstartOfLine = false\n\t\t\telse if (startOfLine)\n\t\t\t\tleadingSpaces++\n\t\t\ti++\n\t\t\tc = code.charAt(i)\n\t\t}, options, codeInput)\n\t\t\n\t\tvar tags = {\n\t\t\tspoiler: \"spoiler\",\n\t\t\talign: \"align\",\n\t\t\tsub: \"subscript\",\n\t\t\tsup: \"superscript\",\n\t\t\tanchor: \"anchor\",\n\t\t\tbg: \"bg\"\n\t\t}\n\t\t\n\t\twhile (c) {\n\t\t\tif (eatChar(\"\\n\")) {\n\t\t\t\tendLine()\n\t\t\t\t//==========\n\t\t\t\t// \\ escape\n\t\t\t} else if (eatChar(\"\\\\\")) {\n\t\t\t\tif (c == \"\\n\") {\n\t\t\t\t\tflushText()\n\t\t\t\t\taddBlock(options.lineBreak())\n\t\t\t\t} else\n\t\t\t\t\taddText(c)\n\t\t\t\tscan()\n\t\t\t\t//===============\n\t\t\t\t// { group start (why did I call these \"groups\"?)\n\t\t\t} else if (c == \"{\") {\n\t\t\t\treadEnv()\n\t\t\t\t//=============\n\t\t\t\t// } group end\n\t\t\t} else if (eatChar(\"}\")) {\n\t\t\t\tif (stackContains(null)) {\n\t\t\t\t\tcloseAll(false)\n\t\t\t\t} else {\n\t\t\t\t\taddText(\"}\")\n\t\t\t\t}\n\t\t\t\t//================\n\t\t\t\t// * heading/bold\n\t\t\t} else if (c == \"*\") {\n\t\t\t\tif (startOfLine && (code[i+1] == \"*\" || code[i+1] == \" \")) {\n\t\t\t\t\tvar headingLevel = 0\n\t\t\t\t\twhile (eatChar(\"*\"))\n\t\t\t\t\t\theadingLevel++\n\t\t\t\t\tif (headingLevel > 3)\n\t\t\t\t\t\theadingLevel = 3\n\t\t\t\t\t\n\t\t\t\t\tif (eatChar(\" \"))\n\t\t\t\t\t\tstartBlock('heading', {}, headingLevel)\n\t\t\t\t\telse\n\t\t\t\t\t\taddMulti('*', headingLevel)\n\t\t\t\t} else {\n\t\t\t\t\tdoMarkup('bold', options.bold)\n\t\t\t\t}\n\t\t\t} else if (c == \"/\") {\n\t\t\t\tdoMarkup('italic', options.italic)\n\t\t\t} else if (c == \"_\") {\n\t\t\t\tdoMarkup('underline', options.underline)\n\t\t\t} else if (c == \"~\") {\n\t\t\t\tdoMarkup('strikethrough', options.strikethrough)\n\t\t\t\t//============\n\t\t\t\t// >... quote\n\t\t\t} else if (startOfLine && eatChar(\">\")) {\n\t\t\t\t// todo: maybe >text should be a quote without author... \n\t\t\t\t// need to add a way to add information to quotes:\n\t\t\t\t// - user ID\n\t\t\t\t// - post ID\n\t\t\t\tlet start = i\n\t\t\t\twhile (eatChar(\" \"))\n\t\t\t\t\t\n\t\t\t\twhile (c && !char_in(c, \" \\n{:\"))\n\t\t\t\t\tscan()\n\t\t\t\tvar name = code.substring(start, i).trim()\n\t\t\t\teatChar(\":\")\n\t\t\t\twhile (eatChar(\" \"))\n\t\t\t\t\t\n\t\t\t\tstartBlock('quote', {}, {\"\":name})\n\t\t\t\t//==============\n\t\t\t\t// -... list/hr\n\t\t\t} else if (startOfLine && eatChar(\"-\")) {\n\t\t\t\ttextBuffer = \"\" //hack:\n\t\t\t\t//----------\n\t\t\t\t// --... hr\n\t\t\t\tif (eatChar(\"-\")) {\n\t\t\t\t\tvar count = 2\n\t\t\t\t\twhile (eatChar(\"-\"))\n\t\t\t\t\t\tcount++\n\t\t\t\t\t//-------------\n\t\t\t\t\t// ---<EOL> hr\n\t\t\t\t\tif (c == \"\\n\" || !c) { //this is kind of bad\n\t\t\t\t\t\taddBlock(options.line())\n\t\t\t\t\t\tskipNextLineBreak = true //hack\n\t\t\t\t\t\t//----------\n\t\t\t\t\t\t// ---... normal text\n\t\t\t\t\t} else {\n\t\t\t\t\t\taddMulti(\"-\", count)\n\t\t\t\t\t}\n\t\t\t\t\t//------------\n\t\t\t\t\t// - ... list\n\t\t\t\t} else if (eatChar(\" \")) {\n\t\t\t\t\tstartBlock('list', {level:leadingSpaces}, {})\n\t\t\t\t\tstartBlock('item', {level:leadingSpaces})\n\t\t\t\t\t//---------------\n\t\t\t\t\t// - normal char\n\t\t\t\t} else\n\t\t\t\t\taddText(\"-\")\n\t\t\t\t//==========================\n\t\t\t\t// ] end link if inside one\n\t\t\t} else if (c == \"]\" && stack.top().inBrackets){ //this might break if it assumes .top() exists. needs more testing\n\t\t\t\tscan()\n\t\t\t\tif (stack.top().big) {\n\t\t\t\t\tif (eatChar(\"]\"))\n\t\t\t\t\t\tendBlock()\n\t\t\t\t\telse\n\t\t\t\t\t\taddText(\"]\")\n\t\t\t\t} else\n\t\t\t\t\tendBlock()\n\t\t\t\t//============\n\t\t\t\t// |... table\n\t\t\t} else if (c == \"|\") {\n\t\t\t\tvar top = stack.top()\n\t\t\t\t// continuation\n\t\t\t\tif (top.type == 'cell') {\n\t\t\t\t\tscan()\n\t\t\t\t\tvar row = top.row\n\t\t\t\t\tvar table = top.row.table\n\t\t\t\t\tvar eaten = eatChar(\"\\n\")\n\t\t\t\t\t//--------------\n\t\t\t\t\t// | | next row\n\t\t\t\t\tif (eaten && eatChar(\"|\")) {\n\t\t\t\t\t\t// number of cells in first row\n\t\t\t\t\t\t// determines number of columns in table\n\t\t\t\t\t\tif (table.columns == null)\n\t\t\t\t\t\t\ttable.columns = row.cells\n\t\t\t\t\t\t// end blocks\n\t\t\t\t\t\tendBlock() //cell\n\t\t\t\t\t\tif (top_is('row')) //always\n\t\t\t\t\t\t\tendBlock()\n\t\t\t\t\t\t// start row\n\t\t\t\t\t\t// calculate number of cells in row which will be\n\t\t\t\t\t\t// already filled due to previous row-spanning cells\n\t\t\t\t\t\tvar cells = 0\n\t\t\t\t\t\ttable.rowspans = table.rowspans.map(function(span){\n\t\t\t\t\t\t\tcells++\n\t\t\t\t\t\t\treturn span-1\n\t\t\t\t\t\t}).filter(function(span){return span > 0})\n\t\t\t\t\t\tvar row = startBlock('row', {table:table, cells:cells})\n\t\t\t\t\t\trow.header = eatChar(\"*\")\n\t\t\t\t\t\t// start cell\n\t\t\t\t\t\tstartCell(row)\n\t\t\t\t\t\t//--------------------------\n\t\t\t\t\t\t// | next cell or table end\n\t\t\t\t\t} else {\n\t\t\t\t\t\trow.cells++\n\t\t\t\t\t\ttextBuffer = textBuffer.replace(/ *$/,\"\") //strip trailing spaces (TODO: allow \\<space>)\n\t\t\t\t\t\t// end of table\n\t\t\t\t\t\t// table ends when number of cells in current row = number of cells in first row\n\t\t\t\t\t\t// single-row tables are not easily possible ..\n\t\t\t\t\t\t// TODO: fix single row tables\n\t\t\t\t\t\tif (table.columns != null && row.cells > table.columns) {\n\t\t\t\t\t\t\tendBlock() //end cell\n\t\t\t\t\t\t\tif (top_is('row')) //always\n\t\t\t\t\t\t\t\tendBlock() //row\n\t\t\t\t\t\t\tif (top_is('table')) //always\n\t\t\t\t\t\t\t\tendBlock() //table\n\t\t\t\t\t\t\tif (eaten)\n\t\t\t\t\t\t\t\taddLineBreak()\n\t\t\t\t\t\t} else { // next cell\n\t\t\t\t\t\t\tendBlock() //cell\n\t\t\t\t\t\t\tstartCell(row)\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t// start of new table (must be at beginning of line)\n\t\t\t\t} else if (startOfLine) {\n\t\t\t\t\tscan()\n\t\t\t\t\ttable = startBlock('table', {\n\t\t\t\t\t\tcolumns: null,\n\t\t\t\t\t\trowspans: []\n\t\t\t\t\t}, {})\n\t\t\t\t\trow = startBlock('row', {\n\t\t\t\t\t\ttable: table,\n\t\t\t\t\t\tcells: 0\n\t\t\t\t\t})\n\t\t\t\t\trow.header = eatChar(\"*\")\n\t\t\t\t\tstartCell(row)\n\t\t\t\t} else {\n\t\t\t\t\tscan()\n\t\t\t\t\taddText(\"|\")\n\t\t\t\t}\n\t\t\t\t//===========\n\t\t\t\t// `... code\n\t\t\t} else if (eatChar(\"`\")) {\n\t\t\t\t//---------------\n\t\t\t\t// ``...\n\t\t\t\tif (eatChar(\"`\")) {\n\t\t\t\t\t//----------------\n\t\t\t\t\t// ``` code block\n\t\t\t\t\tif (eatChar(\"`\")) {\n\t\t\t\t\t\t// read lang name\n\t\t\t\t\t\tlet start = i\n\t\t\t\t\t\twhile (c && c!=\"\\n\" && c!=\"`\")\n\t\t\t\t\t\t\tscan()\n\t\t\t\t\t\t//todo: protect against ```why won't this work``` ?\n\t\t\t\t\t\tvar language = code.substring(start, i).trim().toLowerCase()\n\t\t\t\t\t\tvar eaten = eatChar(\"\\n\")\n\t\t\t\t\t\tstart = i\n\t\t\t\t\t\ti = code.indexOf(\"```\", i)\n\t\t\t\t\t\taddBlock(options.code(\n\t\t\t\t\t\t\t{\"\": language},\n\t\t\t\t\t\t\tcode.substring(start, i!=-1 ? i : code.length)\n\t\t\t\t\t\t))\n\t\t\t\t\t\tskipNextLineBreak = eaten\n\t\t\t\t\t\tif (i != -1) {\n\t\t\t\t\t\t\trestore(i + 3)\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\trestore(code.length)\n\t\t\t\t\t\t}\n\t\t\t\t\t\t//------------\n\t\t\t\t\t\t// `` invalid\n\t\t\t\t\t} else {\n\t\t\t\t\t\taddText(\"``\")\n\t\t\t\t\t}\n\t\t\t\t\t// --------------\n\t\t\t\t\t// ` inline code\n\t\t\t\t} else {\n\t\t\t\t\tlet start = i\n\t\t\t\t\tvar codeText = \"\"\n\t\t\t\t\twhile (c) {\n\t\t\t\t\t\tif (c==\"`\") {\n\t\t\t\t\t\t\tif (code[i+1] == \"`\") {\n\t\t\t\t\t\t\t\tif (i == start+1 && codeText[0] == \" \")\n\t\t\t\t\t\t\t\t\tcodeText = codeText.substr(1)\n\t\t\t\t\t\t\t\tscan()\n\t\t\t\t\t\t\t} else\n\t\t\t\t\t\t\t\tbreak\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcodeText += c\n\t\t\t\t\t\tscan()\n\t\t\t\t\t}\n\t\t\t\t\taddBlock(options.icode({},codeText))\n\t\t\t\t\tscan()\n\t\t\t\t}\n\t\t\t\t//\n\t\t\t\t//================\n\t\t\t\t// link\n\t\t\t} else if (readLink()) {\n\t\t\t\t//\n\t\t\t\t//=============\n\t\t\t\t// normal char\n\t\t\t} else {\n\t\t\t\taddText(c)\n\t\t\t\tscan()\n\t\t\t}\n\t\t}\n\t\t// END\n\t\tendAll()\n\t\treturn output.node\n\t\t\n\t\t\n\t\t// ###################################\n\t\t\n\t\tfunction readBracketedLink(embed) {\n\t\t\tif (eatChar(\"[\")) {\n\t\t\t\tif (eatChar(\"[\")) {\n\t\t\t\t\t// read url:\n\t\t\t\t\tvar start = i\n\t\t\t\t\tvar part2 = false\n\t\t\t\t\tvar url = readUrl(true)\n\t\t\t\t\tif (eatChar(\"]\")) {\n\t\t\t\t\t\tif (eatChar(\"]\")){\n\t\t\t\t\t\t}else if (eatChar(\"[\"))\n\t\t\t\t\t\t\tpart2 = true\n\t\t\t\t\t}\n\t\t\t\t\tif (embed)\n\t\t\t\t\t\tvar type = urlType(url);\n\t\t\t\t\telse\n\t\t\t\t\t\ttype = 'link';\n\t\t\t\t\tif (type == \"youtube\") {\n\t\t\t\t\t\taddBlock(options.youtube({\"\":url}, preview));\n\t\t\t\t\t\tif (part2)\n\t\t\t\t\t\t\taddText(\"[\") // scary\n\t\t\t\t\t} else {\n\t\t\t\t\t\tstartBlock(type, {big: true}, {\"\":url}, preview)\n\t\t\t\t\t\tif (part2)\n\t\t\t\t\t\t\tstack.top().inBrackets = true\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\taddText(url)\n\t\t\t\t\t\t\tendBlock()\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\treturn true\n\t\t\t\t} else {\n\t\t\t\t\taddText(\"[\")\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn false\n\t\t}\n\t\t\n\t\tfunction readEnv() {\n\t\t\tif (!eatChar(\"{\"))\n\t\t\t\treturn false\n\t\t\tstartBlock(null, {})\n\t\t\tlineStart()\n\t\t\t\n\t\t\tvar start = i\n\t\t\tif (eatChar(\"#\")){\n\t\t\t\tvar name = readTagName()\n\t\t\t\tvar props = readProps()\n\t\t\t\t// todo: make this better lol\n\t\t\t\tvar func = tags[name]\n\t\t\t\tif (func && !(name==\"spoiler\" && stackContains(\"spoiler\"))) {\n\t\t\t\t\tstartBlock(func, {}, props)\n\t\t\t\t} else {\n\t\t\t\t\taddBlock(options.invalid(code.substring(start, i), \"invalid tag\"))\n\t\t\t\t}\n\t\t\t\t/*if (displayBlock({type:name}))\n\t\t\t\t  skipNextLineBreak = true; //what does this even do?*/\n\t\t\t}\n\t\t\tlineStart()\n\t\t\t//\teatChar(\"\\n\")\n\t\t\treturn true\n\t\t}\n\t\t\n\t\t// read table cell properties and start cell block, and eat whitespace\n\t\t// assumed to be called when pointing to char after |\n\t\tfunction startCell(row) {\n\t\t\tvar props = {}\n\t\t\tif (eatChar(\"#\"))\n\t\t\t\tObject.assign(props, readProps())\n\t\t\t\n\t\t\tif (props.rs)\n\t\t\t\trow.table.rowspans.push(props.rs-1)\n\t\t\tif (props.cs)\n\t\t\t\trow.cells += props.cs-1\n\t\t\t\n\t\t\tif (row.header)\n\t\t\t\tprops.h = true\n\t\t\t\n\t\t\tstartBlock('cell', {row: row}, props)\n\t\t\twhile (eatChar(\" \")){\n\t\t\t}\n\t\t}\n\n\t\t// split string on first occurance\n\t\tfunction split1(string, sep) {\n\t\t\tvar n = string.indexOf(sep)\n\t\t\tif (n == -1)\n\t\t\t\treturn [string, null]\n\t\t\telse\n\t\t\t\treturn [string.substr(0,n), string.substr(n+sep.length)]\n\t\t}\n\t\t\n\t\tfunction readTagName() {\n\t\t\tvar start = i\n\t\t\twhile (c>=\"a\" && c<=\"z\") {\n\t\t\t\tscan()\n\t\t\t}\n\t\t\tif (i > start)\n\t\t\t\treturn code.substring(start, i)\n\t\t}\n\t\t\n\t\t// read properties key=value,key=value... ended by a space or \\n or } or {\n\t\t// =value is optional and defaults to `true`\n\t\tfunction readProps() {\n\t\t\tvar start = i\n\t\t\tvar end = code.indexOf(\" \", i)\n\t\t\tif (end < 0)\n\t\t\t\tend = code.length\n\t\t\tvar end2 = code.indexOf(\"\\n\", i)\n\t\t\tif (end2 >= 0 && end2 < end)\n\t\t\t\tend = end2\n\t\t\tend2 = code.indexOf(\"}\", i)\n\t\t\tif (end2 >= 0 && end2 < end)\n\t\t\t\tend = end2\n\t\t\tend2 = code.indexOf(\"{\", i)\n\t\t\tif (end2 >= 0 && end2 < end)\n\t\t\t\tend = end2\n\n\n\t\t\trestore(end)\n\t\t\teatChar(\" \")\n\n\t\t\tvar propst = code.substring(start, end)\n\t\t\tvar props = {}\n\t\t\tpropst.split(\",\").forEach(function(x){\n\t\t\t\tvar pair = split1(x, \"=\")\n\t\t\t\tif (pair[1] == null)\n\t\t\t\t\tpair[1] = true\n\t\t\t\tprops[pair[0]] = pair[1]\n\t\t\t})\n\t\t\treturn props\n\t\t}\n\n\t\t// string.repeat doesn't exist\n\t\tfunction addMulti(text, count) {\n\t\t\twhile (count --> 0)\n\t\t\t\taddText(text)\n\t\t}\n\n\t\tfunction readLink() {\n\t\t\tvar embed = eatChar(\"!\")\n\t\t\tif (readBracketedLink(embed) || readPlainLink(embed))\n\t\t\t\treturn true\n\t\t\telse if (embed) {\n\t\t\t\taddText(\"!\")\n\t\t\t\treturn true\n\t\t\t\t//lesson: if anything is eaten, you must return true if it's in the top level if switch block\n\t\t\t}\n\t\t}\n\n\t\tfunction readPlainLink(embed) {\n\t\t\tif (isUrlStart()) {\n\t\t\t\tvar url = readUrl()\n\t\t\t\tvar after = eatChar(\"[\")\n\t\t\t\t\n\t\t\t\tif (embed)\n\t\t\t\t\tvar type = urlType(url);\n\t\t\t\telse\n\t\t\t\t\ttype = 'link';\n\t\t\t\tif (type == \"youtube\") {\n\t\t\t\t\taddBlock(options.youtube({\"\":url}, preview));\n\t\t\t\t\tif (after)\n\t\t\t\t\t\taddText(\"[\") // scary\n\t\t\t\t} else {\n\t\t\t\t\tstartBlock(type, {inBrackets: after}, {\"\":url}, preview)\n\t\t\t\t\tif (!after) {\n\t\t\t\t\t\taddText(url)\n\t\t\t\t\t\tendBlock()\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn true\n\t\t\t}\n\t\t}\n\t\t\n\t\t// closeAll(true) - called at end of document\n\t\t// closeAll(false) - called at end of {} block\n\t\tfunction closeAll(force) {\n\t\t\twhile(stack.length) {\n\t\t\t\tvar top = stack.top()\n\t\t\t\tif (top.type == 'root') {\n\t\t\t\t\tbreak\n\t\t\t\t}\n\t\t\t\tif (!force && top.type == null) {\n\t\t\t\t\tendBlock()\n\t\t\t\t\tbreak\n\t\t\t\t}\n\t\t\t\tendBlock()\n\t\t\t}\n\t\t}\n\n\t\t// called at the end of a line (unescaped newline)\n\t\tfunction endLine() {\n\t\t\twhile (1) {\n\t\t\t\tvar top = stack.top()\n\t\t\t\tif (top.type == 'heading' || top.type == 'quote') {\n\t\t\t\t\tendBlock()\n\t\t\t\t} else if (top.type == 'item') {\n\t\t\t\t\tif (top.type == 'item')\n\t\t\t\t\t\tendBlock()\n\t\t\t\t\tvar indent = 0\n\t\t\t\t\twhile (eatChar(\" \"))\n\t\t\t\t\t\tindent++\n\t\t\t\t\t// OPTION 1:\n\t\t\t\t\t// no next item; end list\n\t\t\t\t\tif (c != \"-\") {\n\t\t\t\t\t\twhile (top_is('list')) //should ALWAYS happen at least once\n\t\t\t\t\t\t\tendBlock()\n\t\t\t\t\t\taddMulti(\" \", indent)\n\t\t\t\t\t} else {\n\t\t\t\t\t\tscan()\n\t\t\t\t\t\twhile (eatChar(\" \")) {}\n\t\t\t\t\t\t// OPTION 2:\n\t\t\t\t\t\t// next item has same indent level; add item to list\n\t\t\t\t\t\tif (indent == top.level) {\n\t\t\t\t\t\t\tstartBlock('item', {level: indent})\n\t\t\t\t\t\t\t// OPTION 3:\n\t\t\t\t\t\t\t// next item has larger indent; start nested list\t\n\t\t\t\t\t\t} else if (indent > top.level) {\n\t\t\t\t\t\t\tstartBlock('list', {level: indent}, {})\n\t\t\t\t\t\t\tstartBlock('item', {level: indent}) // then made the first item of the new list\n\t\t\t\t\t\t\t// OPTION 4:\n\t\t\t\t\t\t\t// next item has less indent; try to exist 1 or more layers of nested lists\n\t\t\t\t\t\t\t// if this fails, fall back to just creating a new item in the current list\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t// TODO: currently this will just fail completely \n\t\t\t\t\t\t\twhile(1) {\n\t\t\t\t\t\t\t\ttop = stack.top()\n\t\t\t\t\t\t\t\tif (top && top.type == 'list') {\n\t\t\t\t\t\t\t\t\tif (top.level <= indent) {\n\t\t\t\t\t\t\t\t\t\tbreak\n\t\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\t\tendBlock()\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\t// no suitable list was found :(\n\t\t\t\t\t\t\t\t\t// so just create a new one\n\t\t\t\t\t\t\t\t\tstartBlock('list', {level: indent}, {})\n\t\t\t\t\t\t\t\t\tbreak\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tstartBlock('item', {level: indent})\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak //really?\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\taddLineBreak()\n\t\t\t\t\tbreak\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// audio, video, image, youtube\n\t\t//todo: improve this lol\n\t\tfunction urlType(url) {\n\t\t\tif (/(\\.mp3(?!\\w)|\\.ogg(?!\\w)|\\.wav(?!\\w)|#audio$)/.test(url))\n\t\t\t\treturn \"audio\"\n\t\t\tif (/(\\.mp4(?!\\w)|\\.mkv(?!\\w)|#video$)/.test(url))\n\t\t\t\treturn \"video\"\n\t\t\tif (/(?:https?:\\/\\/)?(?:www\\.)?youtu\\.?be(?:\\.com)?\\/?.*(?:watch|embed)?(?:.*v=|v\\/|\\/)([\\w\\-_]+)\\&?/.test(url))\n\t\t\t\treturn \"youtube\"\n\t\t\treturn \"image\"\n\t\t}\n\n\t\t// common code for all text styling tags (bold etc.)\n\t\tfunction doMarkup(type, create) {\n\t\t\tvar symbol = c\n\t\t\tscan()\n\t\t\tif (canStartMarkup(type)) {\n\t\t\t\tstartBlock(type, {})\n\t\t\t} else if (canEndMarkup(type)) {\n\t\t\t\tendBlock()\n\t\t\t} else {\n\t\t\t\taddText(symbol)\n\t\t\t}\n\t\t}\n\t\t// todo: maybe have support for non-ASCII punctuation/whitespace?\n\t\tfunction canStartMarkup(type) {\n\t\t\treturn (\n\t\t\t\t(!code[i-2] || char_in(code[i-2], \" \\t\\n({'\\\"\")) && //prev char is one of these (or start of text)\n\t\t\t\t(c && !char_in(c, \" \\t\\n,'\\\"\")) && //next char is not one of these\n\t\t\t\t!stackContains(type)\n\t\t\t)\n\t\t}\n\t\tfunction canEndMarkup(type) {\n\t\t\treturn (\n\t\t\t\ttop_is(type) && //there is an item to close\n\t\t\t\t!char_in(code[i-2], \" \\t\\n,'\\\"\") && //prev char is not one of these\n\t\t\t\t(!c || char_in(c, \" \\t\\n-.,:!?')}\\\"\")) //next char is one of these (or end of text)\n\t\t\t)\n\t\t}\n\t\tfunction char_in(chr, list) {\n\t\t\treturn chr && list.indexOf(chr) != -1\n\t\t}\n\t\t\n\t\tfunction lineStart() {\n\t\t\tstartOfLine = true\n\t\t\tleadingSpaces = 0\n\t\t}\n\t\t\n\t}\n\n\tParse.lang.bbcode = function(codeArg, preview) {\n\t\tvar noNesting = {\n\t\t\tspoiler:true\n\t\t}\n\t\tvar blocks = {\n\t\t\tb: options.bold,\n\t\t\ti: options.italic,\n\t\t\tu: options.underline,\n\t\t\ts: options.strikethrough,\n\t\t\tsup: options.superscript,\n\t\t\tsub: options.subscript,\n\t\t\th1: function(){return options.heading(1)},\n\t\t\th2: function(){return options.heading(2)},\n\t\t\th3: function(){return options.heading(3)},\n\t\t\ttable: options.table,\n\t\t\ttr: options.row,\n\t\t\ttd: options.cell,\n\t\t\tth: function(arg, opt){\n\t\t\t\treturn options.cell(Object.assign({h:true}, opt))\n\t\t\t},\n\t\t\tcode: false, \n\t\t\talign: options.align,\n\t\t\turl: options.link,//+<VERY special case> (only hardcode when no argument)\n\t\t\tyoutube: true, //<special case>,\n\t\t\taudio: true,\n\t\t\tvideo: true,\n\t\t\timg: true, //<special case>,\n\t\t\tlist: options.list,\n\t\t\tspoiler: options.spoiler,\n\t\t\tquote: options.quote,\n\t\t\tanchor: options.anchor,\n\t\t\titem: options.item,\n\t\t}\n\t\tinit(function() {\n\t\t\ti++\n\t\t\tc = code.charAt(i)\n\t\t}, blocks, codeArg)\n\t\t\n\t\tvar specialBlock = {\n\t\t\turl: function(args, contents){\n\t\t\t\tvar node = options.link({\"\":contents})\n\t\t\t\toptions.append(node, options.text(contents))\n\t\t\t\treturn node\n\t\t\t},\n\t\t\tcode: function(args, contents) {\n\t\t\t\tvar inline = args[\"\"] == 'inline'\n\t\t\t\targs[\"\"] = args.lang\n\t\t\t\tif (inline)\n\t\t\t\t\treturn options.icode(args, contents)\n\t\t\t\t\n\t\t\t\tif (contents[0]==\"\\n\")\n\t\t\t\t\tcontents = contents.substr(1)\n\t\t\t\treturn options.code(args, contents)\n\t\t\t},\n\t\t\tyoutube: function(args, contents) {\n\t\t\t\treturn options.youtube({\"\":contents}, preview)\n\t\t\t},\n\t\t\timg: function(args, contents) {\n\t\t\t\treturn options.image({\"\":contents})\n\t\t\t},\n\t\t\taudio: function(args, contents) {\n\t\t\t\treturn options.audio({\"\":contents})\n\t\t\t},\n\t\t\tvideo: function(args, contents) {\n\t\t\t\treturn options.video({\"\":contents})\n\t\t\t}\n\t\t}\n\n\t\tvar point = 0\n\t\t\n\t\twhile (c) {\n\t\t\t//===========\n\t\t\t// [... tag?\n\t\t\tif (eatChar(\"[\")) {\n\t\t\t\tpoint = i-1\n\t\t\t\t// [/... end tag?\n\t\t\t\tif(eatChar(\"/\")) {\n\t\t\t\t\tvar name = readTagName()\n\t\t\t\t\t// invalid end tag\n\t\t\t\t\tif (!eatChar(\"]\") || !name) {\n\t\t\t\t\t\tcancel()\n\t\t\t\t\t// valid end tag\n\t\t\t\t\t} else {\n\t\t\t\t\t\t// end last item in lists\n\t\t\t\t\t\tif (name == \"list\" && stack.top().type == \"item\")\n\t\t\t\t\t\t\tendBlock(point)\n\t\t\t\t\t\tif (name == stack.top().type) {\n\t\t\t\t\t\t\tendBlock(point)\n\t\t\t\t\t\t\t// eat whitespace between table cells\n\t\t\t\t\t\t\tif (name == 'td' || name == 'th' || name == 'tr') {\n\t\t\t\t\t\t\t\twhile(eatChar(' ')||eatChar('\\n')){\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\taddBlock(options.invalid(code.substring(point, i), \"unexpected closing tag\"))\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t// [... start tag?\n\t\t\t\t} else {\n\t\t\t\t\tvar name = readTagName()\n\t\t\t\t\tif (!name || !blocks[name]) {\n\t\t\t\t\t\t// special case [*] list item\n\t\t\t\t\t\tif (eatChar(\"*\") && eatChar(\"]\")) {\n\t\t\t\t\t\t\tif (stack.top().type == \"item\")\n\t\t\t\t\t\t\t\tendBlock(point)\n\t\t\t\t\t\t\tvar top = stack.top()\n\t\t\t\t\t\t\tif (top.type == \"list\") {\n\t\t\t\t\t\t\t\tstartBlock(\"item\", {}, {})\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t\tcancel()\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tcancel()\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\t// [tag=...\n\t\t\t\t\t\tvar arg = true, args = {}\n\t\t\t\t\t\tif (eatChar(\"=\")) {\n\t\t\t\t\t\t\tvar start=i\n\t\t\t\t\t\t\tif (eatChar('\"')) {\n\t\t\t\t\t\t\t\tstart++\n\t\t\t\t\t\t\t\twhile (c && c!='\"')\n\t\t\t\t\t\t\t\t\tscan()\n\t\t\t\t\t\t\t\tif (c == '\"') {\n\t\t\t\t\t\t\t\t\targ = code.substring(start, i-1)\n\t\t\t\t\t\t\t\t\tscan()\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\twhile (c && c!=\"]\" && c!=\" \")\n\t\t\t\t\t\t\t\t\tscan()\n\t\t\t\t\t\t\t\tif (c == \"]\" || c == \" \")\n\t\t\t\t\t\t\t\t\targ = code.substring(start, i)\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (eatChar(\" \")) {\n\t\t\t\t\t\t\targs = readArgList() || {}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (arg!=true)\n\t\t\t\t\t\t\targs[\"\"] = arg\n\t\t\t\t\t\tif (eatChar(\"]\")) {\n\t\t\t\t\t\t\tif (specialBlock[name] && !(name == \"url\" && arg!=true)) {\n\t\t\t\t\t\t\t\tvar endTag = \"[/\"+name+\"]\"\n\t\t\t\t\t\t\t\tvar end = code.indexOf(endTag, i)\n\t\t\t\t\t\t\t\tif (end < 0)\n\t\t\t\t\t\t\t\t\tcancel()\n\t\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\t\tvar contents = code.substring(i, end)\n\t\t\t\t\t\t\t\t\trestore(end + endTag.length)\n\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t\t// todo: this can't handle args with caching currently\n\t\t\t\t\t\t\t\t\tvar node = tryGetCached(cache, name, contents, function() {\n\t\t\t\t\t\t\t\t\t\treturn specialBlock[name](args, contents)\n\t\t\t\t\t\t\t\t\t})\n\t\t\t\t\t\t\t\t\taddBlock(node)\n\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t\tif (node.block)\n\t\t\t\t\t\t\t\t\t\tskipNextLineBreak = true\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t} else if (name!=\"item\" && blocks[name] && !(noNesting[name] && stackContains(name))) {\n\t\t\t\t\t\t\t\tif (name == 'tr' || name == 'table') {\n\t\t\t\t\t\t\t\t\twhile(eatChar(' ')||eatChar('\\n')){\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tstartBlock(name, {}, args)\n\t\t\t\t\t\t\t} else\n\t\t\t\t\t\t\t\taddBlock(options.invalid(code.substring(point, i), \"invalid tag\"))\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tcancel()\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else if (readPlainLink()) {\n\t\t\t} else if (eatChar('\\n')) {\n\t\t\t\taddLineBreak()\n\t\t\t} else {\n\t\t\t\taddText(c)\n\t\t\t\tscan()\n\t\t\t}\n\t\t}\n\t\tendAll()\n\t\treturn output.node\n\t\t\n\t\tfunction cancel() {\n\t\t\trestore(point)\n\t\t\taddText(c)\n\t\t\tscan()\n\t\t}\n\n\t\tfunction readPlainLink() {\n\t\t\tif (isUrlStart()) {\n\t\t\t\tvar url = readUrl()\n\t\t\t\taddBlock(specialBlock.url({},url))\n\t\t\t\treturn true\n\t\t\t}\n\t\t}\n\n\t\tfunction readArgList() {\n\t\t\tvar args = {}\n\t\t\twhile (1) {\n\t\t\t\t// read key\n\t\t\t\tvar start = i\n\t\t\t\twhile (isTagChar(c))\n\t\t\t\t\tscan()\n\t\t\t\tvar key = code.substring(start, i)\n\t\t\t\t// key=...\n\t\t\t\tif (eatChar(\"=\")) {\n\t\t\t\t\t// key=\"...\n\t\t\t\t\tif (eatChar('\"')) {\n\t\t\t\t\t\tstart = i\n\t\t\t\t\t\twhile (c && c!='\"' && c!=\"\\n\")\n\t\t\t\t\t\t\tscan()\n\t\t\t\t\t\tif (eatChar('\"'))\n\t\t\t\t\t\t\targs[key] = code.substring(start, i-2)\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\treturn null\n\t\t\t\t\t\t// key=...\n\t\t\t\t\t} else {\n\t\t\t\t\t\tstart = i\n\t\t\t\t\t\twhile (c && c!=\" \" && c!=\"]\" && c!=\"\\n\")\n\t\t\t\t\t\t\tscan()\n\t\t\t\t\t\tif (c == \"]\") {\n\t\t\t\t\t\t\targs[key] = code.substring(start, i)\n\t\t\t\t\t\t\treturn args\n\t\t\t\t\t\t} else if (eatChar(\" \"))\n\t\t\t\t\t\t\targs[key] = code.substring(start, i-1)\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\treturn null\n\t\t\t\t\t}\n\t\t\t\t\t// key ...\n\t\t\t\t} else if (eatChar(\" \")) {\n\t\t\t\t\targs[key] = true\n\t\t\t\t\t// key]...\n\t\t\t\t} else if (c == \"]\") {\n\t\t\t\t\targs[key] = true\n\t\t\t\t\treturn args\n\t\t\t\t\t// key<other char> (error)\n\t\t\t\t} else\n\t\t\t\t\treturn null\n\t\t\t}\n\t\t}\n\t\t\n\t\tfunction readTagName() {\n\t\t\tvar start = i\n\t\t\twhile (isTagChar(c))\n\t\t\t\tscan()\n\t\t\treturn code.substring(start, i)\n\t\t}\n\n\t\tfunction isTagChar(c) {\n\t\t\treturn c>=\"a\" && c<=\"z\" || c>=\"A\"&&c<=\"Z\" || c>=\"0\"&&c<=\"9\"\n\t\t}\n\t}\n\t\n\t// \"plain text\" (with autolinker)\n\tParse.fallback = function(text, preview) {\n\t\tvar options = Parse.options\n\t\tvar root = options.root()\n\t\ti = 0\n\t\tcode = text\n\t\toutput = root\n\t\t\n\t\tvar linkRegex = /\\b(?:https?:\\/\\/|sbs:)[-\\w\\$\\.+!*'(),;/\\?:@=&#%]*/g\n\t\tvar result\n\t\tvar out = \"\", last = 0\n\t\twhile (result = linkRegex.exec(text)) {\n\t\t\t// text before link\n\t\t\toptions.append(root, options.text(text.substring(last, result.index)))\n\t\t\t// generate link\n\t\t\tvar link = options.link({\"\": result[0]})\n\t\t\toptions.append(link, options.text(result[0]))\n\t\t\toptions.append(root, link)\n\t\t\t\n\t\t\tlast = result.index + result[0].length\n\t\t}\n\t\t// text after last link (or entire message if no links were found)\n\t\toptions.append(root, options.text(text.substr(last)))\n\t\t\n\t\treturn root.node\n\t}\n\t\n\tParse.parseLang = function(text, lang, preview) {\n\t\ti=0\n\t\tcode = text\n\t\tif (preview) {\n\t\t\tcache = editorCache\n\t\t} else {\n\t\t\tcache = null\n\t\t}\n\t\ttry {\n\t\t\tvar parser = Parse.lang[lang] || Parse.fallback\n\t\t\treturn parser(text, preview)\n\t\t} catch(e) {\n\t\t\ttry {\n\t\t\t\tif (!output) {\n\t\t\t\t\toutput = options.root();\n\t\t\t\t}\n\t\t\t\toptions.append(output, options.error(e, e.stack))\n\t\t\t\toptions.append(output, options.text(code.substr(i)))\n\t\t\t\treturn output.node\n\t\t\t} catch (e) {\n\t\t\t\talert(\"Unrecoverable parser error! please report this!\\n\"+e.stack)\n\t\t\t}\n\t\t}\n\t}\n})()\n\nexport default Parse;"],"sourceRoot":""}